# Импортируем необходимые модули
import socket      # Предоставляет низкоуровневый сетевой интерфейс
import sys         # Для системно-специфических параметров и функций
from concurrent.futures import ThreadPoolExecutor  # Для управления пулом потоков

# Запрашиваем у пользователя имя хоста или IP-адрес для сканирования
host = input("Пожалуйста, введите имя хоста или IP-адрес для сканирования: ")

# Определяем диапазон портов для сканирования
start_port = 1      # Начальный номер порта
end_port = 1024     # Конечный номер порта
# Примечание: измените end_port на 65535, чтобы сканировать все возможные порты

# Информируем пользователя о начале сканирования
print(f"Начинаем сканирование хоста {host} с порта {start_port} до {end_port}")

# Определяем функцию, которая будет сканировать один порт
def scan_port(port):
    """
    Пытается подключиться к заданному хосту на указанном порту.
    Выводит сообщение, если порт открыт.
    """
    try:
        # Создаем новый сокет, используя IPv4 и TCP
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # Устанавливаем таймаут для попытки подключения, чтобы избежать зависаний
        sock.settimeout(1)  # Таймаут в секундах

        # Пытаемся подключиться к хосту на указанном порту
        result = sock.connect_ex((host, port))
        if result == 0:
            # Если попытка подключения возвращает 0, порт открыт
            print(f"Порт {port} открыт")
        else:
            # Если попытка подключения не удалась, порт закрыт или фильтруется
            pass

        # Закрываем сокет, чтобы освободить порт
        sock.close()
    except KeyboardInterrupt:
        # Позволяем пользователю прервать сканирование с помощью Ctrl+C
        print("\nСканирование прервано пользователем.")
        sys.exit()
    except socket.gaierror:
        # Обрабатываем ошибки, когда имя хоста не может быть разрешено
        print(f"Имя хоста '{host}' не может быть разрешено. Выход.")
        sys.exit()
    except socket.error:
        # Обрабатываем другие ошибки сокета
        print(f"Не удалось подключиться к серверу '{host}'. Выход.")
        sys.exit()

# Используем ThreadPoolExecutor для управления пулом потоков
# Оператор 'with' гарантирует, что ресурсы будут быстро освобождены
with ThreadPoolExecutor(max_workers=100) as executor:
    # Отправляем задачи scan_port в исполнитель для каждого порта в заданном диапазоне
    # max_workers определяет максимальное количество потоков, выполняющихся одновременно
    for port in range(start_port, end_port + 1):
        # Отправляем функцию scan_port на выполнение с текущим номером порта
        executor.submit(scan_port, port)
        # Примечание: executor.submit планирует выполнение функции и возвращается немедленно

# После отправки всех задач исполнитель ждет их завершения
# Как только все потоки завершены, программа продолжает работу здесь

# Информируем пользователя о завершении сканирования
print("Сканирование завершено.")